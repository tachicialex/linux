/dts-v1/;
/plugin/;

/ {
	#include <dt-bindings/clock/ad9545.h>
	#include <dt-bindings/iio/frequency/hmc7044.h>

	compatible = "brcm,bcm2835", "brcm,bcm2711";

	fragment@0 {

		target-path = "/";
		__overlay__ {

			ref_clk0: ref_clk_0 {
				compatible = "fixed-clock";
				#clock-cells = <1>;

				clock-frequency  = <1>;
				clock-output-names = "Ref-A";
			};

			ref_clk2: ref_clk_2 {
				compatible = "fixed-clock";
				#clock-cells = <1>;

				clock-frequency  = <10000000>;
				clock-output-names = "Ref-B";
			};

			hmc_ref_clk0: hmc_ref_clk_0 {
				compatible = "fixed-clock";
				#clock-cells = <1>;

				clock-frequency  = <25000000>;
				clock-output-names = "HMC-REF_CLKIN1";
			};

			hmc_ref_clk1: hmc_ref_clk_1 {
				compatible = "fixed-clock";
				#clock-cells = <1>;

				clock-frequency  = <25000000>;
				clock-output-names = "HMC-REF_CLKIN2";
			};

			hmc_ref_clk2: hmc_ref_clk_2 {
				compatible = "fixed-clock";
				#clock-cells = <1>;

				clock-frequency  = <38400000>;
				clock-output-names = "HMC-REF_CLKIN3";
			};

			spi0 {
				compatible = "spi-gpio";
				#address-cells = <0x1>;
				#size-cells = <0>;

				gpio-mosi = <&gpio 10 0>;
				gpio-miso = <&gpio 9 0>;
				gpio-sck = <&gpio 11 0>;
				cs-gpios = <&gpio 8 1>, <&gpio 7 1>;
				num-chipselects = <2>;
				status = "okay";

				ad9545_clock: ad9545@0 {
					compatible = "adi,ad9545";
					reg = <0>;

					#address-cells = <1>;
					#size-cells = <0>;

					adi,ref-crystal;
					adi,ref-frequency-hz = <49152000>;
					spi-max-frequency = <100000>;

					clock-names = "Ref-A", "Ref-B";
					clocks = <&ref_clk0 0>, <&ref_clk2 2>;

					#clock-cells = <2>;
					assigned-clocks = <&ad9545_clock AD9545_CLK_NCO AD9545_NCO0>,
							  <&ad9545_clock AD9545_CLK_PLL AD9545_PLL0>,
							  <&ad9545_clock AD9545_CLK_OUT AD9545_Q0A>;
					assigned-clock-rates = <10000>, <1400000000>, <25000000>;

					/* ref a*/
					ref-input-clk@0 {
					  reg = <0>;
					  adi,single-ended-mode = <DRIVER_MODE_AC_COUPLED>;
					  adi,r-divider-ratio = <1>;
					  adi,ref-dtol-pbb = <10000000>;
					  adi,ref-monitor-hysteresis-pbb = <87500>;
					  adi,ref-validation-timer-ms = <1>;
					  adi,freq-lock-threshold-ps = <0xFFFFFF>;
					  adi,phase-lock-threshold-ps = <0xFFFFFF>;
					};

					/* ref b*/
					ref-input-clk@2 {
					  reg = <2>;
					  adi,single-ended-mode = <DRIVER_MODE_AC_COUPLED>;
					  adi,r-divider-ratio = <200>;
					  adi,ref-dtol-pbb = <10000000>;
					  adi,ref-monitor-hysteresis-pbb = <87500>;
					  adi,ref-validation-timer-ms = <1>;
					  adi,freq-lock-threshold-ps = <0xFFFFFF>;
					  adi,phase-lock-threshold-ps = <0xFFFFFF>;
					};

					aux-nco-clk@AD9545_NCO0 {
						reg = <AD9545_NCO0>;
						adi,freq-lock-threshold-ps = <16000000>;
						adi,phase-lock-threshold-ps = <16000000>;
					};

					ad9545_apll0: pll-clk@AD9545_PLL0 {
						reg = <AD9545_PLL0>;

						#address-cells = <1>;
						#size-cells = <0>;

						profile@0 {
							reg = <0>;
							adi,pll-source = <2>;
							adi,profile-priority = <10>;
							adi,pll-loop-bandwidth-uhz = <200000000>;
						};

						profile@1 {
							reg = <1>;
							adi,pll-source = <0>;
							adi,profile-priority = <0>;
							adi,pll-loop-bandwidth-uhz = <6000>;
							adi,fast-acq-excess-bw = <512>;
							adi,fast-acq-timeout-ms = <100>;
							adi,fast-acq-lock-settle-ms = <100>;
						};
					};

					output-clk@AD9545_Q0A {
						reg = <AD9545_Q0A>;
						adi,output-mode = <DRIVER_MODE_SINGLE_DIV_DIF>;
						adi,current-source;
						adi,current-source-microamp = <15000>;
					};
				};

				hmc7044_fmc: hmc7044@1 {
					reg = <0x1>;

					#address-cells = <1>;
					#size-cells = <0>;
					#clock-cells = <1>;

					compatible = "adi,hmc7044";
					spi-max-frequency = <100000>;

					adi,pll1-clkin-frequencies = <25000000 25000000 25000000 38400000>;
					adi,pll1-ref-prio-ctrl = <0xE4>; /* CLKIN0 -> CLKIN1 -> CLKIN2 -> CLKIN3 */
					adi,pll1-loop-bandwidth-hz = <200>;

					adi,clkin0-buffer-mode = <0x05>;
					adi,clkin1-buffer-mode  = <0x05>;
					adi,clkin2-buffer-mode  = <0x05>;
					adi,clkin3-buffer-mode  = <0x05>;

					clocks = <&ad9545_clock AD9545_CLK_OUT AD9545_Q0A>, <&hmc_ref_clk0 0>, <&hmc_ref_clk1 0>, <&hmc_ref_clk2 0>;
					clock-names = "clkin0", "clkin1", "clkin2", "clkin3";

					adi,pfd1-maximum-limit-frequency-hz = <3840000>;

					/* depends on VCXO_SELECT_PI */
					adi,vcxo-frequency = <100000000>;
					adi,pll2-output-frequency = <3000000000>;
					adi,sysref-timer-divider = <3840>;
					adi,pulse-generator-mode = <HMC7044_PULSE_GEN_CONT_PULSE>;

					adi,oscin-buffer-mode = <0x15>;
					adi,sync-pin-mode = <HMC7044_SYNC_PIN_SYNC>;

					adi,gpi-controls = <0x00 0x00 0x00 0x00>;
					adi,gpo-controls = <0x1f 0x2b 0x00 0x00>;

					clock-output-names = "HMC7044_OUT0", "HMC7044_OUT1",
							     "HMC7044_OUT2", "HMC7044_OUT3",
							     "HMC7044_OUT4", "HMC7044_OUT5",
							     "HMC7044_OUT6", "HMC7044_OUT7",
							     "HMC7044_OUT8", "HMC7044_OUT9",
							     "HMC7044_OUT10", "HMC7044_OUT11",
							     "HMC7044_OUT12", "HMC7044_OUT13";

					/*
					 * Channels in CMOS mode should configure
					 * adi,driver-impedance-mode to:
					 * 0 - no output
					 * 1 - N output
					 * 2 - P ourput
					 * 3 - both
					 * Depending on the desired output pin.
					 */

					channel@0 {
						reg = <0>;
						adi,extended-name = "HMC7044_OUT0";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_LVPECL>;
					};

					channel@1 {
						reg = <1>;
						adi,extended-name = "HMC7044_OUT1";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_LVPECL>;
					};

					channel@2 {
						reg = <2>;
						adi,extended-name = "HMC7044_OUT2";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_LVPECL>;
					};

					channel@3 {
						reg = <3>;
						adi,extended-name = "HMC7044_OUT3";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_LVPECL>;
					};

					channel@4 {
						reg = <4>;
						adi,extended-name = "HMC7044_OUT4";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_CMOS>;
					};

					channel@5 {
						reg = <5>;
						adi,extended-name = "HMC7044_OUT5";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_LVPECL>;
					};

					channel@6 {
						reg = <6>;
						adi,extended-name = "HMC7044_OUT6";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_CMOS>;
						adi,driver-impedance-mode = <3>;
					};

					channel@7 {
						reg = <7>;
						adi,extended-name = "HMC7044_OUT7";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_LVDS>;
					};

					channel@8 {
						reg = <8>;
						adi,extended-name = "HMC7044_OUT8";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_LVDS>;
					};

					channel@9 {
						reg = <9>;
						adi,extended-name = "HMC7044_OUT9";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_LVDS>;
					};

					channel@10 {
						reg = <10>;
						adi,extended-name = "HMC7044_OUT10";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_LVDS>;
					};

					channel@11 {
						reg = <11>;
						adi,extended-name = "HMC7044_OUT11";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_CMOS>;
					};

					channel@12 {
						reg = <12>;
						adi,extended-name = "HMC7044_OUT12";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_LVPECL>;
					};

					channel@13 {
						reg = <13>;
						adi,extended-name = "HMC7044_OUT13";
						adi,divider = <120>;
						adi,driver-mode = <HMC7044_DRIVER_MODE_CMOS>;
						adi,driver-impedance-mode = <3>;
					};
				};
			};
		};
	};

	fragment@1 {
		target = <&gpio>;
		__overlay__ {
			ad-synchrona14_pins {
				/* GPIO_4_HMC7044_CAR - 4
				 * GPIO_1_HMC7044_CAR - 17
				 * GPIO_2_HMC7044_CAR - 27
				 * GPIO_3_HMC7044_CAR - 22
				 * RESETB_AD9545_PI - 25
				 * RESET_HMC7044_CAR_PI - 5
				 * VCXO_SELECT_PI - 6
				 * GPIO19_PI - 19
				 * GPIO26_PI - 26
				 */
				brcm,pins = <4 17 27 22 25 5 6 19 26>;
				brcm,function = <1 1 1 1 1 1 1 1 1>;
				brcm,pull = <0 0 0 2 2 1 0 0 0>;
			};
		};
	};

	fragment@2 {
		target = <&spidev0>;
		__overlay__ {
			status = "okay";
		};
	};

	fragment@3 {
		target = <&spidev1>;
		__overlay__ {
			status = "okay";
		};
	};
};
